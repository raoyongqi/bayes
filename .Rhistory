install.packages("fixest")
# On multiple estimations: see the dedicated vignette
est = feols(Ozone ~ Solar.R + sw0(Wind + Temp) | csw(Month, Day),
airquality, cluster = ~Day)
library(fixest)
data(airquality)
est = feols(Ozone ~ Solar.R + sw0(Wind + Temp) | csw(Month, Day),
airquality, cluster = ~Day)
View(est)
View(airquality)
View(airquality)
source("C:/Users/r/Desktop/bayes/bayes.R", echo=TRUE)
library(brms)
library(brms)
fit <- brm(count ~ zAge + zBase * Trt
+ (1|patient) + (1|visit),
data = epilepsy, family = "poisson")
system('gcc --version')
library(brms)
fit <- brm(count ~ zAge + zBase * Trt
+ (1|patient) + (1|visit),
data = epilepsy, family = "poisson")
fit <- brm(count ~ zAge + zBase * Trt
+ (1|patient) + (1|visit),
data = epilepsy, family = "poisson")
plot(fit)
library(brms)
fit <- brm(count ~ zAge + zBase * Trt
+ (1|patient) + (1|visit),
data = epilepsy, family = "poisson")
plot(fit)
View(epilepsy)
bayes_R2(fit, newdata = nd)
source("C:/Users/r/Desktop/bayes/bayes.R", echo=TRUE)
fit1 <- brm(
count ~ zAge + zBase + Trt,
data = epilepsy, family = negbinomial(),
prior = prior(normal(0, 1), class = b),
save_all_pars = TRUE
)
summary(fit1)
library(Boruta)
install.packages("Boruta")
new_columns <- sapply(names(data), function(col) {
new_columns <- sapply(names(data), function(col) {
source("C:/Users/r/Desktop/bayes/bayes.R", echo=TRUE)
source("C:/Users/r/Desktop/bayes/bayes.R", echo=TRUE)
source("C:/Users/r/Desktop/bayes/bayes.R", echo=TRUE)
source("C:/Users/r/Desktop/bayes/bayes.R", echo=TRUE)
# 加载必要的包
library(readxl)
library(dplyr)
library(randomForest)
library(Boruta)
# 1. 读取 Excel 文件
file_path <- "data/climate_soil.xlsx"  # 替换为你的文件路径
data <- read_excel(file_path)
install.packages("tidybayes")
library(ggplot2)
library(dplyr)
library(posterior)
library(brms)
library(modelr)
theme_set(theme_light())
m_mpg = brm(mpg ~ hp * cyl, data = mtcars, family = lognormal(),
# 1 chain / few iterations just so example runs quickly
# do not use in practice
chains = 1, iter = 500)
theme_set(theme_light())
m_mpg = brm(mpg ~ hp * cyl, data = mtcars, family = lognormal(),
# 1 chain / few iterations just so example runs quickly
# do not use in practice
chains = 1, iter = 500)
# Look at mean predictions for some cars (epred) and compare to
# the exponeniated mu parameter of the lognormal distribution (linpred).
# Notice how they are NOT the same. This is because exp(mu) for a
# lognormal distribution is equal to its median, not its mean.
mtcars %>%
select(hp, cyl, mpg) %>%
add_epred_rvars(m_mpg) %>%
add_linpred_rvars(m_mpg, value = "mu") %>%
mutate(expmu = exp(mu), .epred - expmu)
# plot intervals around conditional means (epred_rvars)
mtcars %>%
group_by(cyl) %>%
data_grid(hp = seq_range(hp, n = 101)) %>%
add_epred_rvars(m_mpg) %>%
ggplot(aes(x = hp, color = ordered(cyl), fill = ordered(cyl))) +
stat_lineribbon(aes(dist = .epred), .width = c(.95, .8, .5), alpha = 1/3) +
geom_point(aes(y = mpg), data = mtcars) +
scale_color_brewer(palette = "Dark2") +
scale_fill_brewer(palette = "Set2")
# plot posterior predictive intervals (predicted_rvars)
mtcars %>%
group_by(cyl) %>%
data_grid(hp = seq_range(hp, n = 101)) %>%
add_predicted_rvars(m_mpg) %>%
ggplot(aes(x = hp, color = ordered(cyl), fill = ordered(cyl))) +
stat_lineribbon(aes(dist = .prediction), .width = c(.95, .8, .5), alpha = 1/3) +
geom_point(aes(y = mpg), data = mtcars) +
scale_color_brewer(palette = "Dark2") +
scale_fill_brewer(palette = "Set2")
library(tidybayes)
# Look at mean predictions for some cars (epred) and compare to
# the exponeniated mu parameter of the lognormal distribution (linpred).
# Notice how they are NOT the same. This is because exp(mu) for a
# lognormal distribution is equal to its median, not its mean.
mtcars %>%
select(hp, cyl, mpg) %>%
add_epred_rvars(m_mpg) %>%
add_linpred_rvars(m_mpg, value = "mu") %>%
mutate(expmu = exp(mu), .epred - expmu)
# plot intervals around conditional means (epred_rvars)
mtcars %>%
group_by(cyl) %>%
data_grid(hp = seq_range(hp, n = 101)) %>%
add_epred_rvars(m_mpg) %>%
ggplot(aes(x = hp, color = ordered(cyl), fill = ordered(cyl))) +
stat_lineribbon(aes(dist = .epred), .width = c(.95, .8, .5), alpha = 1/3) +
geom_point(aes(y = mpg), data = mtcars) +
scale_color_brewer(palette = "Dark2") +
scale_fill_brewer(palette = "Set2")
# plot posterior predictive intervals (predicted_rvars)
mtcars %>%
group_by(cyl) %>%
data_grid(hp = seq_range(hp, n = 101)) %>%
add_predicted_rvars(m_mpg) %>%
ggplot(aes(x = hp, color = ordered(cyl), fill = ordered(cyl))) +
stat_lineribbon(aes(dist = .prediction), .width = c(.95, .8, .5), alpha = 1/3) +
geom_point(aes(y = mpg), data = mtcars) +
scale_color_brewer(palette = "Dark2") +
scale_fill_brewer(palette = "Set2")
library("bayesplot")
library("rstanarm")
install.packages("rstanarm")
library("bayesplot")
library("rstanarm")
library("ggplot2")
fit <- stan_glm(mpg ~ ., data = mtcars)
posterior <- as.matrix(fit)
plot_title <- ggtitle("Posterior distributions",
"with medians and 80% intervals")
mcmc_areas(posterior,
pars = c("cyl", "drat", "am", "wt"),
prob = 0.8) + plot_title
library("bayesplot")
library("rstanarm")
library("ggplot2")
file_path <- "selection.csv"  # 替换为你的文件路径
selection <- read.csv(file_path)
fit <- stan_glm(mpg ~ ., data = selection)
setwd("C:/Users/r/Desktop/bayes")
fit <- stan_glm(mpg ~ ., data = selection)
posterior <- as.matrix(fit)
setwd("C:/Users/r/Desktop/bayes")
file_path <- "selection.csv"  # 替换为你的文件路径
selection <- read.csv(file_path)
fit <- stan_glm(mpg ~ ., data = selection)
View(selection)
library("bayesplot")
library("rstanarm")
library("ggplot2")
setwd("C:/Users/r/Desktop/bayes")
file_path <- "selection.csv"  # 替换为你的文件路径
selection <- read.csv(file_path)
fit <- stan_glm(Ratio ~ ., data = selection)
View(selection)
library("bayesplot")
library("rstanarm")
library("ggplot2")
setwd("C:/Users/r/Desktop/bayes")
file_path <- "selection.csv"  # 替换为你的文件路径
selection <- read.csv(file_path)
fit <- stan_glm(RATIO ~ ., data = selection)
posterior <- as.matrix(fit)
mcmc_areas(posterior,
pars = colnames(posterior),
prob = 0.8) + plot_title
View(posterior)
colnames(posterior)
mcmc_areas(posterior,
prob = 0.8) + plot_title
mcmc_areas(posterior,
pars = c("SARD"),
prob = 0.8) + plot_title
# 创建每个变量的单独图
plots <- lapply(colnames(posterior), function(var) {
mcmc_areas(posterior,
pars = var,
prob = 0.8) +
ggtitle(paste("Posterior distribution for", var)) +
theme_minimal()
})
# 用 patchwork 拼接所有图
final_plot <- wrap_plots(plots, ncol = 2)  # ncol 控制列数
library(patchwork)
# 用 patchwork 拼接所有图
final_plot <- wrap_plots(plots, ncol = 2)  # ncol 控制列数
print(final_plot)
View(selection)
install.packages("Hmisc")
library("bayesplot")
library("rstanarm")
library("ggplot2")
library(patchwork)
setwd("C:/Users/r/Desktop/bayes")
file_path <- "selection.csv"  # 替换为你的文件路径
selection <- read.csv(file_path)
result <- rcorr(as.matrix(selection))  # 将数据框转为矩阵
library("bayesplot")
library("rstanarm")
library("ggplot2")
library(patchwork)
library(Hmisc)
setwd("C:/Users/r/Desktop/bayes")
file_path <- "selection.csv"  # 替换为你的文件路径
selection <- read.csv(file_path)
result <- rcorr(as.matrix(selection))  # 将数据框转为矩阵
install.packages("corrplot")  # 可视化相关系数
# 绘制相关系数热图
corrplot(result$r, method = "color",
type = "lower",  # 仅展示下三角矩阵
addCoef.col = "black",  # 显示相关系数值
tl.col = "black", tl.srt = 45,  # 标签颜色和角度
p.mat = result$P, sig.level = 0.05)  # 标记显著性
library("bayesplot")
library("rstanarm")
library("ggplot2")
library(patchwork)
library(Hmisc)
library(corrplot)
# 绘制相关系数热图
corrplot(result$r, method = "color",
type = "lower",  # 仅展示下三角矩阵
addCoef.col = "black",  # 显示相关系数值
tl.col = "black", tl.srt = 45,  # 标签颜色和角度
p.mat = result$P, sig.level = 0.05)  # 标记显著性
install.packages("xtable")  # 用于生成 LaTeX 表格
library(Hmisc)
library(Hmisc)
library(xtable)
file_path <- "C:/Users/r/Desktop/bayes/selection.csv"  # 替换为你的文件路径
selection <- read.csv(file_path)
# 计算 Spearman 相关系数
result <- rcorr(as.matrix(selection), type = "spearman")
# 提取矩阵
cor_matrix <- result$r
p_matrix <- result$P
# 格式化相关系数矩阵
formatted_matrix <- apply(cor_matrix, c(1, 2), function(x) sprintf("%.2f", x))
formatted_matrix[lower.tri(formatted_matrix)] <- NA
# 添加显著性标记
for (i in 1:nrow(p_matrix)) {
for (j in 1:ncol(p_matrix)) {
if (!is.na(p_matrix[i, j]) && p_matrix[i, j] < 0.05) {
formatted_matrix[i, j] <- paste0(formatted_matrix[i, j], "*")
}
}
}
# 转换为数据框并输出 LaTeX
formatted_df <- as.data.frame(formatted_matrix)
cor_table <- xtable(formatted_df, align = rep("c", ncol(formatted_df) + 1))
print(cor_table, include.rownames = TRUE, booktabs = TRUE, file = "correlation_table.tex")
install.packages("vegan")
library(vegan)
data(varespec)
data(varechem)
ord <- metaMDS(varespec)
plot(ord, type = "t")
## Fit environmental variables
ef <- envfit(ord, varechem)
ef
plot(ef, p.max = 0.05)
### Example 2: Constrained ordination (RDA)
## The example uses formula interface to define the model
data(dune)
data(dune.env)
## No constraints: PCA
mod0 <- rda(dune ~ 1, dune.env)
mod0
plot(mod0)
## All environmental variables: Full model
mod1 <- rda(dune ~ ., dune.env)
mod1
plot(mod1)
## Automatic selection of variables by permutation P-values
mod <- ordistep(mod0, scope=formula(mod1))
mod
plot(mod)
## Permutation test for all variables
anova(mod)
## Permutation test of "type III" effects, or significance when a term
## is added to the model after all other terms
anova(mod, by = "margin")
## Plot only sample plots, use different symbols and draw SD ellipses
## for Managemenet classes
plot(mod, display = "sites", type = "n")
with(dune.env, points(mod, disp = "si", pch = as.numeric(Management)))
with(dune.env, legend("topleft", levels(Management), pch = 1:4,
title = "Management"))
with(dune.env, ordiellipse(mod, Management, label = TRUE))
## add fitted surface of diversity to the model
ordisurf(mod, diversity(dune), add = TRUE)
### Example 3: analysis of dissimilarites a.k.a. non-parametric
### permutational anova
adonis2(dune ~ ., dune.env)
adonis2(dune ~ Management + Moisture, dune.env)
data(mite)
data(mite.xy)
mite.hel <- decostand(mite, "hellinger")
# Detrend the species data by regression on the site coordinates
mite.hel.resid <- resid(lm(as.matrix(mite.hel) ~ ., data=mite.xy))
# Compute the detrended species distance matrix
mite.hel.D <- dist(mite.hel.resid)
# Compute Mantel correlogram with cutoff, Pearson statistic
mite.correlog <- mantel.correlog(mite.hel.D, XY=mite.xy, nperm=49)
summary(mite.correlog)
mite.correlog
# or: print(mite.correlog)
# or: print.mantel.correlog(mite.correlog)
plot(mite.correlog)
View(mite)
View(mite)
View(mite.xy)
View(mite)
View(mite.xy)
View(mite)
source("C:/Users/r/Desktop/bayes/bayes3.R", echo=TRUE)
plot(procrustes(rda(sptrans), cca(varespec)))
data(varespec)
sptrans <- decostand(varespec, "max")
apply(sptrans, 2, max)
sptrans <- wisconsin(varespec)
# CLR transformation for rows, with pseudocount
varespec.clr <- decostand(varespec, "clr", pseudocount=1)
# ALR transformation for rows, with pseudocount and reference sample
varespec.alr <- decostand(varespec, "alr", pseudocount=1, reference=1)
## Chi-square: PCA similar but not identical to CA.
## Use wcmdscale for weighted analysis and identical results.
sptrans <- decostand(varespec, "chi.square")
plot(procrustes(rda(sptrans), cca(varespec)))
View(mite.hel)
library("bayesplot")
library("rstanarm")
library("ggplot2")
setwd("C:/Users/r/Desktop/bayes")
file_path <- "selection.csv"  # 替换为你的文件路径
selection <- read.csv(file_path)
# 对自变量进行标准化，保持因变量不变
selection_scaled <- selection
selection_scaled[ , -which(names(selection) == "RATIO")] <- scale(selection[ , -which(names(selection) == "RATIO")])
# 使用标准化后的数据进行拟合
fit <- stan_glm(RATIO ~ ., data = selection_scaled)
# 提取后验分布并绘制
posterior <- as.matrix(fit)
plot_title <- ggtitle("Posterior distributions",
"with medians and 80% intervals")
mcmc_areas(posterior,
pars =  colnames(posterior),
prob = 0.8) + plot_title
plot_title <- ggtitle("Posterior distributions",
"with medians and 80% intervals")
mcmc_areas(posterior,
pars =  colnames(posterior),
prob = 0.8) + plot_title
# 提取后验分布并绘制
posterior <- as.matrix(fit)
plot_title <- ggtitle("Posterior distributions",
"with medians and 80% intervals")
mcmc_areas(posterior,
pars =  colnames(posterior),
prob = 0.8) + plot_title
# 提取后验分布并绘制
posterior <- as.matrix(fit)
plot_title <- ggtitle("Posterior distributions",
"with medians and 80% intervals")
mcmc_areas(posterior,
pars =  colnames(posterior),
prob = 0.8) + plot_title
library("bayesplot")
library("rstanarm")
library("ggplot2")
setwd("C:/Users/r/Desktop/bayes")
file_path <- "selection.csv"  # 替换为你的文件路径
selection <- read.csv(file_path)
# 对自变量进行标准化，保持因变量不变
selection_scaled <- selection
selection_scaled[ , -which(names(selection) == "RATIO")] <- scale(selection[ , -which(names(selection) == "RATIO")])
# 使用标准化后的数据进行拟合
fit <- stan_glm(RATIO ~ ., data = selection_scaled)
# 提取后验分布并绘制
posterior <- as.matrix(fit)
plot_title <- ggtitle("Posterior distributions",
"with medians and 80% intervals")
mcmc_areas(posterior,
pars =  colnames(posterior),
prob = 0.8) + plot_title
mcmc_areas(posterior,
pars =  colnames(posterior),
prob = 0.8) + plot_title
